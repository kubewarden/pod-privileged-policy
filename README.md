Continuous integration | License
 -----------------------|--------
![Continuous integration](https://github.com/kubewarden/pod-privileged-policy/workflows/Continuous%20integration/badge.svg) | [![License: Apache 2.0](https://img.shields.io/badge/License-Apache2.0-brightgreen.svg)](https://opensource.org/licenses/Apache-2.0)

This project contains a Kubewarden policy written using [AssemblyScript](https://assemblyscript.org/),
a subset of TypeScript.

# The goal

Given the following scenario:

> As an operator of a Kubernetes cluster used by multiple users,
> I want to have tight control over who can schedule privileged containers.

Kubernetes containers can be run in privileged mode by providing a well crafted
[SecurityContext](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).

Cluster administrators can prevent regular users to create privileged containers
by using a Kubernetes built-in feature called [Pod Security Policies](https://kubernetes.io/docs/concepts/policy/pod-security-policy/).

However, Pod Security Polices are still in Beta phase and they are probably
going to be [deprecated](https://github.com/kubernetes/enhancements/issues/5)
in the near future.

Pod Security Policies could be replaced by using policies provided by an
external Admission Controller, like Kubewarden.

This policy inspects the [AdmissionReview](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#request)
objects generated by the Kubernetes API server and either accept or reject
them.

The policy can be used to inspect `CREATE` and `UPDATE` requests of
`Pod` resources.

## Examples

The following Pod specification doesn't have any security context defined:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
```

This workload can be scheduled by all the users of the cluster.

This Pod specification has one of its containers running in
privileged mode:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  runtimeClassName: containerd-runc
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
    securityContext:
      privileged: true
  - name: sleeping-sidecar
    image: alpine
    command: ["sleep", "1h"]
```

# Obtain policy

The policy is automatically published as an OCI artifact inside of
[this](https://github.com/orgs/kubewarden/packages/container/package/policies%2Fpod-privileged)
container registry:

# Building

This policy is written using [AssemblyScript](https://www.assemblyscript.org/).
The [as-wasi](https://github.com/jedisct1/as-wasi) library is used to target
the [WASI interface](https://wasi.dev/).

JSON parsing and encoding is handled via the [assemblyscript-json](https://github.com/nearprotocol/assemblyscript-json)
library.

Unit testing is done using the [as-pect](https://github.com/jtenner/as-pect)
library.

Building can be done using this command:

```
$ make build
```

This will produce the following Wasm binaries:

  * `policy.wasm`: binary built with release optimizations, copied from
    `build/optimized.wasm`
  * `build/untouched.wasm`: binary built without optimizations

# Using the policy

The easiest way to use this policy is through the [kubewarden-controller](https://github.com/kubewarden/kubewarden-controller).

# Trying the policy

The policy can be ran outside of Kubewarden's [policy-server](https://github.com/kubewarden/policy-server)
by using [policy-testdrive](https://github.com/kubewarden/policy-server/tree/main/crates/policy-testdrive)
CLI tool:

```shell
$ policy-testdrive \
    --policy build/optimized.wasm \
    --request-file assembly/__tests__/fixtures/privileged_container.json
```

This will produce the following output:

```shell
ValidationResponse { accepted: true, message: Some(""), code: None }
```

You can find more example files under the `assembly/__tests__/fixtures/`
directory.

# Testing

Unit tests can be run via:

```shell
$ make test
```
